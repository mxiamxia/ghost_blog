{"meta":{"exported_on":1470334316183,"version":"003"},"data":{"posts":[{"id":2,"uuid":"a03f1598-6256-4d7e-96b2-9460c09b4bc7","title":"New Start In 2015","slug":"new-start-in-2015","markdown":"All my happy starts with my beautiful wife and cute son!\n\n![Me and Pan](/content/images/2015/05/photo-11.jpg)\n![My son Eric](/content/images/2015/05/IMG_5745.JPG)","html":"<p>All my happy starts with my beautiful wife and cute son!</p>\n\n<p><img src=\"/content/images/2015/05/photo-11.jpg\" alt=\"Me and Pan\" />\n<img src=\"/content/images/2015/05/IMG_5745.JPG\" alt=\"My son Eric\" /></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1431567195485,"created_by":1,"updated_at":1433865424152,"updated_by":1,"published_at":1431567852570,"published_by":1},{"id":3,"uuid":"55bb7b81-d0cf-4d5f-bca5-e7379649465a","title":"Three Sum O(n^2) Solution","slug":"three-sum-solution","markdown":"It takes a while to figure out the solution on O(n^2) with no extra spaces. The idea is that loop the array to make each of integer as target, check the other two integers in the rest of array if it is sum to the negatives of the target, add these three integers into result list.\n\nThere is another Hashtable solution for 3Sum which is a transform from 2Sum solution. But it needs extra spaces.\n\nPay attention to,\n\n  * check boundary as always\n  * Duplicated solution\n  * Move pointer smart\n  \n\n\nQuestion,\nGiven an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\n\nSolution,\n\n    public class ThreeSum {\n\n\t/** \n\t * @author Min\n\t * @date May 13, 2015\n\t * @return void \n\t * @throws \n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint[] input = {-2,0,1,1,2};\n\t\tthreeSum(input);\n\t}\n\t public static List<List<Integer>> threeSum(int[] nums) {\n\t        List<List<Integer>> result = new  ArrayList<List<Integer>>();\n\t        if(nums.length<3)\n\t        {\n\t            return result;\n\t        }\n\t        Arrays.sort(nums);\n\t        for(int i=0;i<nums.length-2;i++)\n\t        {\n\t        \t//Avoid duplicated calculation if neighbors are the same\n\t            if(i==0 || nums[i]>nums[i-1])\n\t            {\n\t                int neg = -nums[i];\n\t                int start = i+1;\n\t                int end = nums.length-1;\n\t                while(start<end)\n\t                {\n\t                    if((nums[start]+nums[end])==neg)\n\t                    {\n\t                        List<Integer> each = new ArrayList<Integer>();\n\t                        each.add(nums[i]);\n\t                        each.add(nums[start]);\n\t                        each.add(nums[end]);\n\t                        start++;\n\t\t\t\t\t\t    end--;\n\t\t\t\t\t\t    //avoid duplicate solution\n\t                        if(!result.contains(each))\n\t                        {\n\t                        \tresult.add(each);\n\t                        }\n\t                    }\n\t                    //if \n\t                    else if(nums[start]+nums[end]<neg)\n\t                    {\n\t                    \tstart++;\n\t                    }\n\t                    else\n\t                    {\n\t                    \tend--;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return result;\n\t    }\n    }\n\n","html":"<p>It takes a while to figure out the solution on O(n^2) with no extra spaces. The idea is that loop the array to make each of integer as target, check the other two integers in the rest of array if it is sum to the negatives of the target, add these three integers into result list.</p>\n\n<p>There is another Hashtable solution for 3Sum which is a transform from 2Sum solution. But it needs extra spaces.</p>\n\n<p>Pay attention to,</p>\n\n<ul>\n<li>check boundary as always</li>\n<li>Duplicated solution</li>\n<li>Move pointer smart</li>\n</ul>\n\n<p>Question, <br />\nGiven an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>\n\n<p>Solution,</p>\n\n<pre><code>public class ThreeSum {\n\n/** \n * @author Min\n * @date May 13, 2015\n * @return void \n * @throws \n */\npublic static void main(String[] args) {\n    // TODO Auto-generated method stub\n    int[] input = {-2,0,1,1,2};\n    threeSum(input);\n}\n public static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {\n        List&lt;List&lt;Integer&gt;&gt; result = new  ArrayList&lt;List&lt;Integer&gt;&gt;();\n        if(nums.length&lt;3)\n        {\n            return result;\n        }\n        Arrays.sort(nums);\n        for(int i=0;i&lt;nums.length-2;i++)\n        {\n            //Avoid duplicated calculation if neighbors are the same\n            if(i==0 || nums[i]&gt;nums[i-1])\n            {\n                int neg = -nums[i];\n                int start = i+1;\n                int end = nums.length-1;\n                while(start&lt;end)\n                {\n                    if((nums[start]+nums[end])==neg)\n                    {\n                        List&lt;Integer&gt; each = new ArrayList&lt;Integer&gt;();\n                        each.add(nums[i]);\n                        each.add(nums[start]);\n                        each.add(nums[end]);\n                        start++;\n                        end--;\n                        //avoid duplicate solution\n                        if(!result.contains(each))\n                        {\n                            result.add(each);\n                        }\n                    }\n                    //if \n                    else if(nums[start]+nums[end]&lt;neg)\n                    {\n                        start++;\n                    }\n                    else\n                    {\n                        end--;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1431977570391,"created_by":1,"updated_at":1432007179288,"updated_by":1,"published_at":1431979365724,"published_by":1},{"id":5,"uuid":"b4cc32e6-0d59-4d45-8e49-bca1ba57a97f","title":"Be careful on contains() method","slug":"be-careful-on-contains-method","markdown":"It is very important to understand how to use contains() method in Map/Set, otherwise unexpected result you may get.\n\n1. A common mistake\nYou will not able to get \"green\" Apple object in this example since the one you stored at the beginning and the one you queried is two different objects.\n\n    \timport java.util.HashMap;\n\t\tpublic class Apple {\n\t\t\tprivate String color;\t\t \n\t\t\tpublic Apple(String color) {\n\t\t\t\tthis.color = color;\n\t\t\t}\t\t \n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif (!(obj instanceof Apple))\n\t\t\t\t\treturn false;\t\n\t\t\t\tif (obj == this)\n\t\t\t\t\treturn true;\n\t\t\t\treturn this.color.equals(((Apple) obj).color);\n\t\t\t}\t\t \n\t\t\tpublic static void main(String[] args) {\n\t\t\t\tApple a1 = new Apple(\"green\");\n\t\t\t\tApple a2 = new Apple(\"red\");\t\t \n\t\t\t\t//hashMap stores apple type and its quantity\n\t\t\t\tHashMap<Apple, Integer> m = new HashMap<Apple, Integer>();\n\t\t\t\tm.put(a1, 10);\n\t\t\t\tm.put(a2, 20);\n\t\t\t\tSystem.out.println(m.get(new Apple(\"green\")));\n\t\t\t}\n\t\t}\n\n2, fix the issue\nYou have to override hashCode() to object you want to compare, HashCode() will be called inside contains() method from Map/Set to identify if two object are the same or not.\n\n\t\timport java.util.HashMap;\n\t\tpublic class Apple {\n\t\t\tprivate String color;\n\t\t \n\t\t\tpublic Apple(String color) {\n\t\t\t\tthis.color = color;\n\t\t\t}\n\t\t \t@Override\n\t\t\tpublic boolean equals(Object obj) {\n\t\t\t\tif (!(obj instanceof Apple))\n\t\t\t\t\treturn false;\t\n\t\t\t\tif (obj == this)\n\t\t\t\t\treturn true;\n\t\t\t\treturn this.color.equals(((Apple) obj).color);\n\t\t\t}\n\t\t \t@Override  \n  \t\t  \tpublic int hashCode() {  \n\t\t\t\tString s = thiscolor;\n        \t\treturn s.hashCode();\n    \t\t}\n\t\n\t\t\tpublic static void main(String[] args) {\n\t\t\t\tApple a1 = new Apple(\"green\");\n\t\t\t\tApple a2 = new Apple(\"red\");\n\t\t \n\t\t\t\t//hashMap stores apple type and its quantity\n\t\t\t\tHashMap<Apple, Integer> m = new HashMap<Apple, Integer>();\n\t\t\t\tm.put(a1, 10);\n\t\t\t\tm.put(a2, 20);\n\t\t\t\tSystem.out.println(m.get(new Apple(\"green\")));\n\t\t\t}\n\t\t}\n","html":"<p>It is very important to understand how to use contains() method in Map/Set, otherwise unexpected result you may get.</p>\n\n<ol>\n<li><p>A common mistake <br />\nYou will not able to get \"green\" Apple object in this example since the one you stored at the beginning and the one you queried is two different objects.</p>\n\n<pre><code>import java.util.HashMap;\npublic class Apple {\n    private String color;        \n    public Apple(String color) {\n        this.color = color;\n    }        \n    public boolean equals(Object obj) {\n        if (!(obj instanceof Apple))\n            return false;   \n        if (obj == this)\n            return true;\n        return this.color.equals(((Apple) obj).color);\n    }        \n    public static void main(String[] args) {\n        Apple a1 = new Apple(\"green\");\n        Apple a2 = new Apple(\"red\");         \n        //hashMap stores apple type and its quantity\n        HashMap&lt;Apple, Integer&gt; m = new HashMap&lt;Apple, Integer&gt;();\n        m.put(a1, 10);\n        m.put(a2, 20);\n        System.out.println(m.get(new Apple(\"green\")));\n    }\n}\n</code></pre></li>\n</ol>\n\n<p>2, fix the issue <br />\nYou have to override hashCode() to object you want to compare, HashCode() will be called inside contains() method from Map/Set to identify if two object are the same or not.</p>\n\n<pre><code>    import java.util.HashMap;\n    public class Apple {\n        private String color;\n\n        public Apple(String color) {\n            this.color = color;\n        }\n        @Override\n        public boolean equals(Object obj) {\n            if (!(obj instanceof Apple))\n                return false;   \n            if (obj == this)\n                return true;\n            return this.color.equals(((Apple) obj).color);\n        }\n        @Override  \n          public int hashCode() {  \n            String s = thiscolor;\n            return s.hashCode();\n        }\n\n        public static void main(String[] args) {\n            Apple a1 = new Apple(\"green\");\n            Apple a2 = new Apple(\"red\");\n\n            //hashMap stores apple type and its quantity\n            HashMap&lt;Apple, Integer&gt; m = new HashMap&lt;Apple, Integer&gt;();\n            m.put(a1, 10);\n            m.put(a2, 20);\n            System.out.println(m.get(new Apple(\"green\")));\n        }\n    }\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1432925217846,"created_by":1,"updated_at":1434908410241,"updated_by":1,"published_at":1432926187391,"published_by":1},{"id":6,"uuid":"c7f2c183-22ef-46aa-a5bd-b24dd2390bfe","title":"xor operation practice","slug":"xor-practice","markdown":"Code snippet without using xor operation,\n\n\tif ((dividend > 0 && divisor > 0) || (dividend < 0 && divisor < 0))\n\t\treturn ret;\n\telse\n\t\treturn -ret;\n\nEquivalent code snippet with xor operation\n\n\treturn (dividend>0 ^ divisor>0) ? -ret : ret; ","html":"<p>Code snippet without using xor operation,</p>\n\n<pre><code>if ((dividend &gt; 0 &amp;&amp; divisor &gt; 0) || (dividend &lt; 0 &amp;&amp; divisor &lt; 0))\n    return ret;\nelse\n    return -ret;\n</code></pre>\n\n<p>Equivalent code snippet with xor operation</p>\n\n<pre><code>return (dividend&gt;0 ^ divisor&gt;0) ? -ret : ret; \n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1433214295043,"created_by":1,"updated_at":1433214516053,"updated_by":1,"published_at":1433214516055,"published_by":1},{"id":7,"uuid":"ae2a4cef-36c9-45c1-b9ff-ad3ee12f63f0","title":"Two way to implement Hashtable - Chaining and Open Address","slug":"two-way-to-implement-hashtable-chaining-and-open-address","markdown":"###Interface\n\n```java\n    public interface HashTable {\n\t//向散列表中插入一个关键字为theKey的元素obj，若成功返回真否则返回假\n\tboolean insert(Object theKey, Object obj);\n\t\n\t//向散列表中查找并返回给定关键字theKey对应的元素，若查找失败返回空\n\tObject search(Object theKey);\n\t\n\t//从散列表中删除关键字为theKey的元素，若删除成功返回真否则返回假\n\tboolean delete(Object theKey);\n\t\n\t//返回散列表中已存在的元素个数\n\tint size();\n\t\n\t//返回散列表的容量，即散列表的空间大小m的值\n\tint capacity();\n\t\n\t//判断散列表是否为空，若为空则返回真  否则返回假\n\tboolean isEmpty();\n\t\n\t//清楚散列表的所有元素，使之变成一个空表\n\tvoid clear();\n\t\n\t//输出散列表中保存的所有关键字和对应的元素\n\tvoid output();\n\t}\n```\n\n####Separate Chaining\n```java\npublic class SeqHashTable implements HashTable {\n\t\tprivate int m;\t\t\t\t//保存散列表的容量\n\tprivate Object[] key;   \t//定义保存元素关键字的数组\n\tprivate Object[] ht;    \t//定义保存散列表的数组\n\tprivate int n;\t\t\t\t//散列表中已有的元素个数\n\tprivate Object tag;\t\t\t//元素内容被删除后的关键字删除标记\n\t\n\t//散列函数，采用除\n\tprivate int h(Object theKey){\n\t\t//留余数发，若参数不是整数，应设法转换成整数\n\t\treturn (Integer)theKey%m;\n\t}\n\t\n\tpublic SeqHashTable(int mm, Object tag){\n\t\t//假定散列表的容量至少为13\n\t\tif(mm < 13){\n\t\t\tm = 13;\n\t\t}else{\n\t\t\tm = mm;\n\t\t}\n\t\tn=0;\n\t\tkey = new Object[m];\n\t\tht = new Object[m];\n\t\tthis.tag = tag;\t\t\t//置关键字删除标记为参加tag的值\n\t}\n\t\n\t@Override\n\tpublic boolean insert(Object theKey, Object obj) {\n\t\tint d = h(theKey);\n\t\tint temp = d;\n\t\twhile(key[d] != null && key[d].equals(tag) != true){\n\t\t\t//用线性探测法处理冲突，寻找插入位置\n\t\t\tif(key[d].equals(theKey) == true)\n\t\t\t\tbreak;    \t\t\t//元素已经存在，则退出循环\n\t\t\td = (d+1) % m;\n\t\t\tif(d == temp){         \t//查找一周后扔无位置，应重组散列表或退出运行\n\t\t\t\tSystem.out.println(\"散列表无空间，退出运行\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t}\n\t\tif(key[d] == null || key[d].equals(tag)==true){\n\t\t\t//找到插入位置，插入新的关键字和元素并返回真\n\t\t\tkey[d] = theKey;\n\t\t\tht[d] = obj;\n\t\t\tn++;\n\t\t\treturn true;\n\t\t}else{\t\t\t\t//用新元素obj修改已存在的元素并返回假\n\t\t\tht[d] = obj;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object search(Object theKey) {\n\t\tint d= h(theKey);\n\t\tint temp = d;\n\t\twhile(key[d] != null){\n\t\t\tif(key[d].equals(theKey)){\n\t\t\t\treturn ht[d];\n\t\t\t}else{\n\t\t\t\td = (d+1) % m;\n\t\t\t}\n\t\t\tif(d == temp)\n\t\t\t\treturn null;\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean delete(Object theKey) {\n\t\tint d = h(theKey);\n\t\tint temp = d;\n\t\twhile(key[d] != null){\n\t\t\tif(key[d].equals(theKey)){\n\t\t\t\tkey[d] = tag;\n\t\t\t\tht[d] = null;\n\t\t\t\tn--;\n\t\t\t\treturn true;\n\t\t\t}else{\n\t\t\t\td = (d+1)%m;\n\t\t\t}\n\t\t\tif(d==temp){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn n;\n\t}\n\n\t@Override\n\tpublic int capacity() {\n\t\treturn m;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn n==0;\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tfor(int i=0; i<m; i++){\n\t\t\tkey[i] = null;\n\t\t\tht[i] = null;\n\t\t}\n\t\tn=0;\n\t}\n\n\t@Override\n\tpublic void output() {\n\t\tfor(int i=0; i<m; i++){\n\t\t\tif(key[i]==null || key[i].equals(tag))\n\t\t\t\tcontinue;\n\t\t\tSystem.out.println(\"(\" + key[i] + \" \" + ht[i] + \"),\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n    }\n```\n###Open Address implementation\n\n```java\npublic class LinkHashTable implements HashTable {\n\tprivate int m;\t\t\t//保存散列表的容量\n\tprivate HashNode[] ht;\t//定义保存散列表的数组\n\tprivate int n;\t\t\t//散列表中已有的元素个数\n\t\n\t//散列函数\n\tprivate int h(Object theKey){\n\t\treturn (Integer)theKey % m;\n\t}\n\n\tpublic LinkHashTable(int mm){\n\t\tif(mm < 13){\n\t\t\tm = 13;\n\t\t}else{\n\t\t\tm = mm;\n\t\t}\n\t\tn = 0; \n\t\tht = new HashNode[m];\n\t}\n\t\n\t@Override\n\tpublic boolean insert(Object theKey, Object obj) {\n\t\tint d = h(theKey);\n\t\tHashNode p = ht[d];\n\t\t// 从单链表中顺序查找关键字为theKey的节点\n\t\twhile(p != null){\n\t\t\tif(p.key.equals(theKey) == true)\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tp = p.next;\n\t\t}\n\t\t\n\t\tif(p != null){\t\t\t//用新元素obj修改已有节点的元素值并返回假\n\t\t\tp.element = obj;\n\t\t\treturn false;\n\t\t}else{\n\t\t\tp = new HashNode(theKey, obj);\n\t\t\tp.next = ht[d];\n\t\t\tht[d] = p;\n\t\t\tn++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t@Override\n\tpublic Object search(Object theKey) {\n\t\tint d = h(theKey);\n\t\tHashNode p = ht[d];\n\t\twhile(p!=null){\n\t\t\tif(p.key.equals(theKey))\n\t\t\t\treturn p.element;\n\t\t\telse\n\t\t\t\tp = p.next;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic boolean delete(Object theKey) {\n\t\tint d = h(theKey);\n\t\tHashNode p = ht[d], q = null;\t//p指向表头节点，q指向前驱节点，初始为空\n\t\twhile(p != null){\n\t\t\tif(p.key.equals(theKey))\n\t\t\t\tbreak;\n\t\t\telse{\n\t\t\t\tq = p; \n\t\t\t\tp = p.next;\n\t\t\t}\n\t\t}\n\t\tif(p == null)\t\t//没有删除的元素，返回false\n\t\t\treturn false;\n\t\telse if(q == null)\t//删除的是表头节点\n\t\t\tht[d] = p.next;\n\t\telse\t\t\t\t//删除的是非表头节点\n\t\t\tq.next = p.next;\n\t\tn--;\n\t\t\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn n;\n\t}\n\n\t@Override\n\tpublic int capacity() {\n\t\treturn m;\n\t}\n\n\t@Override\n\tpublic boolean isEmpty() {\n\t\treturn n==0;\n\t}\n\n\t@Override\n\tpublic void clear() {\n\t\tfor(int i=0; i<m; i++){\n\t\t\tht[i] = null;\n\t\t}\n\t\tn=0;\n\t}\n\n\t@Override\n\tpublic void output() {\n\t\tfor(int i=0; i<m; i++){\n\t\t\tHashNode p = ht[i];\n\t\t\twhile(p != null){\n\t\t\t\tSystem.out.println(\"(\" + p.key + \" \" + p.element + \"),\");\n\t\t\t\tp = p.next;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t}\n\nclass HashNode {\n\tObject key;\n\tObject element;\n\tHashNode next;\n\tpublic HashNode(Object theKey, Object obj){\n\t\tkey = theKey;\n\t\telement = obj;\n\t\tnext = null;\n\t}\n}\n}\n```\n\n\n","html":"<h3 id=\"interface\">Interface</h3>\n\n<pre><code class=\"language-java\">    public interface HashTable {\n    //向散列表中插入一个关键字为theKey的元素obj，若成功返回真否则返回假\n    boolean insert(Object theKey, Object obj);\n\n    //向散列表中查找并返回给定关键字theKey对应的元素，若查找失败返回空\n    Object search(Object theKey);\n\n    //从散列表中删除关键字为theKey的元素，若删除成功返回真否则返回假\n    boolean delete(Object theKey);\n\n    //返回散列表中已存在的元素个数\n    int size();\n\n    //返回散列表的容量，即散列表的空间大小m的值\n    int capacity();\n\n    //判断散列表是否为空，若为空则返回真  否则返回假\n    boolean isEmpty();\n\n    //清楚散列表的所有元素，使之变成一个空表\n    void clear();\n\n    //输出散列表中保存的所有关键字和对应的元素\n    void output();\n    }\n</code></pre>\n\n<h4 id=\"separatechaining\">Separate Chaining</h4>\n\n<pre><code class=\"language-java\">public class SeqHashTable implements HashTable {  \n        private int m;              //保存散列表的容量\n    private Object[] key;       //定义保存元素关键字的数组\n    private Object[] ht;        //定义保存散列表的数组\n    private int n;              //散列表中已有的元素个数\n    private Object tag;         //元素内容被删除后的关键字删除标记\n\n    //散列函数，采用除\n    private int h(Object theKey){\n        //留余数发，若参数不是整数，应设法转换成整数\n        return (Integer)theKey%m;\n    }\n\n    public SeqHashTable(int mm, Object tag){\n        //假定散列表的容量至少为13\n        if(mm &lt; 13){\n            m = 13;\n        }else{\n            m = mm;\n        }\n        n=0;\n        key = new Object[m];\n        ht = new Object[m];\n        this.tag = tag;         //置关键字删除标记为参加tag的值\n    }\n\n    @Override\n    public boolean insert(Object theKey, Object obj) {\n        int d = h(theKey);\n        int temp = d;\n        while(key[d] != null &amp;&amp; key[d].equals(tag) != true){\n            //用线性探测法处理冲突，寻找插入位置\n            if(key[d].equals(theKey) == true)\n                break;              //元素已经存在，则退出循环\n            d = (d+1) % m;\n            if(d == temp){          //查找一周后扔无位置，应重组散列表或退出运行\n                System.out.println(\"散列表无空间，退出运行\");\n                System.exit(1);\n            }\n        }\n        if(key[d] == null || key[d].equals(tag)==true){\n            //找到插入位置，插入新的关键字和元素并返回真\n            key[d] = theKey;\n            ht[d] = obj;\n            n++;\n            return true;\n        }else{              //用新元素obj修改已存在的元素并返回假\n            ht[d] = obj;\n            return false;\n        }\n    }\n\n    @Override\n    public Object search(Object theKey) {\n        int d= h(theKey);\n        int temp = d;\n        while(key[d] != null){\n            if(key[d].equals(theKey)){\n                return ht[d];\n            }else{\n                d = (d+1) % m;\n            }\n            if(d == temp)\n                return null;\n        }\n\n        return null;\n    }\n\n    @Override\n    public boolean delete(Object theKey) {\n        int d = h(theKey);\n        int temp = d;\n        while(key[d] != null){\n            if(key[d].equals(theKey)){\n                key[d] = tag;\n                ht[d] = null;\n                n--;\n                return true;\n            }else{\n                d = (d+1)%m;\n            }\n            if(d==temp){\n                return false;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public int size() {\n        return n;\n    }\n\n    @Override\n    public int capacity() {\n        return m;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return n==0;\n    }\n\n    @Override\n    public void clear() {\n        for(int i=0; i&lt;m; i++){\n            key[i] = null;\n            ht[i] = null;\n        }\n        n=0;\n    }\n\n    @Override\n    public void output() {\n        for(int i=0; i&lt;m; i++){\n            if(key[i]==null || key[i].equals(tag))\n                continue;\n            System.out.println(\"(\" + key[i] + \" \" + ht[i] + \"),\");\n        }\n        System.out.println();\n    }\n    }\n</code></pre>\n\n<h3 id=\"openaddressimplementation\">Open Address implementation</h3>\n\n<pre><code class=\"language-java\">public class LinkHashTable implements HashTable {  \n    private int m;          //保存散列表的容量\n    private HashNode[] ht;  //定义保存散列表的数组\n    private int n;          //散列表中已有的元素个数\n\n    //散列函数\n    private int h(Object theKey){\n        return (Integer)theKey % m;\n    }\n\n    public LinkHashTable(int mm){\n        if(mm &lt; 13){\n            m = 13;\n        }else{\n            m = mm;\n        }\n        n = 0; \n        ht = new HashNode[m];\n    }\n\n    @Override\n    public boolean insert(Object theKey, Object obj) {\n        int d = h(theKey);\n        HashNode p = ht[d];\n        // 从单链表中顺序查找关键字为theKey的节点\n        while(p != null){\n            if(p.key.equals(theKey) == true)\n                break;\n            else\n                p = p.next;\n        }\n\n        if(p != null){          //用新元素obj修改已有节点的元素值并返回假\n            p.element = obj;\n            return false;\n        }else{\n            p = new HashNode(theKey, obj);\n            p.next = ht[d];\n            ht[d] = p;\n            n++;\n            return true;\n        }\n    }\n\n    @Override\n    public Object search(Object theKey) {\n        int d = h(theKey);\n        HashNode p = ht[d];\n        while(p!=null){\n            if(p.key.equals(theKey))\n                return p.element;\n            else\n                p = p.next;\n        }\n        return null;\n    }\n\n    @Override\n    public boolean delete(Object theKey) {\n        int d = h(theKey);\n        HashNode p = ht[d], q = null;   //p指向表头节点，q指向前驱节点，初始为空\n        while(p != null){\n            if(p.key.equals(theKey))\n                break;\n            else{\n                q = p; \n                p = p.next;\n            }\n        }\n        if(p == null)       //没有删除的元素，返回false\n            return false;\n        else if(q == null)  //删除的是表头节点\n            ht[d] = p.next;\n        else                //删除的是非表头节点\n            q.next = p.next;\n        n--;\n\n        return true;\n    }\n\n    @Override\n    public int size() {\n        return n;\n    }\n\n    @Override\n    public int capacity() {\n        return m;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return n==0;\n    }\n\n    @Override\n    public void clear() {\n        for(int i=0; i&lt;m; i++){\n            ht[i] = null;\n        }\n        n=0;\n    }\n\n    @Override\n    public void output() {\n        for(int i=0; i&lt;m; i++){\n            HashNode p = ht[i];\n            while(p != null){\n                System.out.println(\"(\" + p.key + \" \" + p.element + \"),\");\n                p = p.next;\n            }\n        }\n        System.out.println();\n    }\n\nclass HashNode {  \n    Object key;\n    Object element;\n    HashNode next;\n    public HashNode(Object theKey, Object obj){\n        key = theKey;\n        element = obj;\n        next = null;\n    }\n}\n}\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1435549436359,"created_by":1,"updated_at":1438190425947,"updated_by":1,"published_at":1435549897312,"published_by":1},{"id":8,"uuid":"a678d8af-bf64-45b4-a606-9cdcab387e0d","title":"Permutation Sequence","slug":"permutation-sequence","markdown":"这道题目算法上没有什么特别的，更像是一道找规律的数学题目。我们知道，n个数的permutation总共有n阶乘个，基于这个性质我们可以得到某一位对应的数字是哪一个。思路是这样的，比如当前长度是n，我们知道每个相同的起始元素对应(n-1)!个permutation，也就是(n-1)!个permutation后会换一个起始元素。因此，只要当前的k进行(n-1)!取余，得到的数字就是当前剩余数组的index，如此就可以得到对应的元素。如此递推直到数组中没有元素结束。实现中我们要维护一个数组来记录当前的元素，每次得到一个元素加入结果数组，然后从剩余数组中移除，因此空间复杂度是O(n)。时间上总共需要n个回合，而每次删除元素如果是用数组需要O(n),所以总共是O(n^2)。这里如果不移除元素也需要对元素做标记，所以要判断第一个还是个线性的操作。\n```java\n    public class Solution {\n        public String getPermutation(int n, int k) {\n            if(k == 0) {\n                return null;\n            }\n            List numList = new ArrayList();\n            int f = 1;\n            for(int i=1; i<=n; i++) {\n                numList.add(i);\n                f = f*i;\n            }\n            f = f/n;\n            k--;\n            StringBuffer sb = new StringBuffer();\n            for(int j=0; j<n; j++) {\n                int index = k/f;\n                sb.append(numList.get(index));\n                numList.remove(index);\n                k = k%f;\n                if(j != n-1) {\n                    f = f/(n-j-1);\n                }\n            }\n            return sb.toString();\n        }\n    }\n```","html":"<p>这道题目算法上没有什么特别的，更像是一道找规律的数学题目。我们知道，n个数的permutation总共有n阶乘个，基于这个性质我们可以得到某一位对应的数字是哪一个。思路是这样的，比如当前长度是n，我们知道每个相同的起始元素对应(n-1)!个permutation，也就是(n-1)!个permutation后会换一个起始元素。因此，只要当前的k进行(n-1)!取余，得到的数字就是当前剩余数组的index，如此就可以得到对应的元素。如此递推直到数组中没有元素结束。实现中我们要维护一个数组来记录当前的元素，每次得到一个元素加入结果数组，然后从剩余数组中移除，因此空间复杂度是O(n)。时间上总共需要n个回合，而每次删除元素如果是用数组需要O(n),所以总共是O(n^2)。这里如果不移除元素也需要对元素做标记，所以要判断第一个还是个线性的操作。</p>\n\n<pre><code class=\"language-java\">    public class Solution {\n        public String getPermutation(int n, int k) {\n            if(k == 0) {\n                return null;\n            }\n            List numList = new ArrayList();\n            int f = 1;\n            for(int i=1; i&lt;=n; i++) {\n                numList.add(i);\n                f = f*i;\n            }\n            f = f/n;\n            k--;\n            StringBuffer sb = new StringBuffer();\n            for(int j=0; j&lt;n; j++) {\n                int index = k/f;\n                sb.append(numList.get(index));\n                numList.remove(index);\n                k = k%f;\n                if(j != n-1) {\n                    f = f/(n-j-1);\n                }\n            }\n            return sb.toString();\n        }\n    }\n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1437410577126,"created_by":1,"updated_at":1438190298358,"updated_by":1,"published_at":1437411084434,"published_by":1},{"id":9,"uuid":"601cd336-39db-4277-a20a-eb29dcdd7830","title":"(Untitled)","slug":"untitled","markdown":"As we all known, technical questions count a great part in software engineering interviews. Although I have much project experience, I simply do not feel strong at it, owing to the fact that I am not a formal CSSE student. But anything can be grasped nowadays by self-learning. We have lots of resources on the Internet. Today I want to share with you a method I use for getting familiar with basic algorithms.\nBreakdown\nIf the ability to use algorithms to solve a problem is a kind of skill, there should be a way to to practice it and make it our own. Just like what we do to learn how to play a instrument or to improve athletic performance. This is where I start.\nI started by research on learning methods1. Do you ever think of that learning itself is actually worth learning? It is. In fact, there are tons of ways to help one master a skill. KATA2 is one of them.\nToday I am going to show you what is KATA and explain my own KATA scheme on basic algorithms implementation.\nWhat is KATA?\nThe first time I heard of KATA was in a post named “Improving Skills by Kata”3. KATA is a Japanese word describing detailed choreographed patterns of movements practiced either solo or in pairs. The basic philosophy of KATA is to practice the skill repeatedly to gain muscle memory. The writer learned Ruby basics by setting himself a goal: building a TicTacToe game in less than an hour. Then he did it again and again until he can accomplish this goal easily.\nWhy use KATA?\nKATA is actually a way to do deliberate practice. It is great for solo training because it does not require any supervisory from others. We can easily build a scheme on our own. The only things we need to do are practice, practice and practice.\nHow to use it?\nThe way I make use of KATA is almost the same as that writer. First, I choose several basic algorithms like BFS, DFS, merge sort, quick sort, binary search, tree traversal and etc. Then I start to implement them one by one and set up testing environment. I also set a goal for each of them, say for merge sort, my goals are to finish it within 4 minutes and write perfect code for 10 times in a row. Once I get prepared, I can go ahead and do the coding day by day. Another important thing is to keep a log. An basic log should be a record of results. For example, this time I implemented a merge sort in 03m56s correctly. To make it simple, we may use a table with 3 columns: file name, correctness and time.\nResult\nI absolutely benefited a lot from my KATA scheme(otherwise I would not share it with you). At the very beginning I was not able to implement any of basic algorithms I chose. The first time I struggled to do merge sort in more than 20 minutes. Now I can my best record for merge sort is 3 minutes 16 seconds. See? KATA is absolutely efficient and useful.\nWeakness\nKATA is great but not perfect. It is good for gaining muscle memory. I do not even need to think about the actual code when I practice because it is already there in my mind and my hands. But I have to remind you that it would be much better if you understand the algorithm fully. If you do it every day, you probably will not need to care about that. But if you stop for some time, you will not remember a thing and lose your head. So it is more important to remember the structure of the algorithm, reason every detail in code and generate your own comprehension. That will make you even more powerful.\nLooking for Partner\nI am doing my second round KATA on algorithms training now and am looking for someone or some guys who are interested to join me. This time I would include more common algorithms. It will not cost more than 30 minutes per day after you grasp the basic ideas and set up your own training environment. And you definitely will be deep impressed by how KATA reform your confidence on technical questions.","html":"<p>As we all known, technical questions count a great part in software engineering interviews. Although I have much project experience, I simply do not feel strong at it, owing to the fact that I am not a formal CSSE student. But anything can be grasped nowadays by self-learning. We have lots of resources on the Internet. Today I want to share with you a method I use for getting familiar with basic algorithms. <br />\nBreakdown <br />\nIf the ability to use algorithms to solve a problem is a kind of skill, there should be a way to to practice it and make it our own. Just like what we do to learn how to play a instrument or to improve athletic performance. This is where I start. <br />\nI started by research on learning methods1. Do you ever think of that learning itself is actually worth learning? It is. In fact, there are tons of ways to help one master a skill. KATA2 is one of them. <br />\nToday I am going to show you what is KATA and explain my own KATA scheme on basic algorithms implementation. <br />\nWhat is KATA? <br />\nThe first time I heard of KATA was in a post named “Improving Skills by Kata”3. KATA is a Japanese word describing detailed choreographed patterns of movements practiced either solo or in pairs. The basic philosophy of KATA is to practice the skill repeatedly to gain muscle memory. The writer learned Ruby basics by setting himself a goal: building a TicTacToe game in less than an hour. Then he did it again and again until he can accomplish this goal easily. <br />\nWhy use KATA? <br />\nKATA is actually a way to do deliberate practice. It is great for solo training because it does not require any supervisory from others. We can easily build a scheme on our own. The only things we need to do are practice, practice and practice. <br />\nHow to use it? <br />\nThe way I make use of KATA is almost the same as that writer. First, I choose several basic algorithms like BFS, DFS, merge sort, quick sort, binary search, tree traversal and etc. Then I start to implement them one by one and set up testing environment. I also set a goal for each of them, say for merge sort, my goals are to finish it within 4 minutes and write perfect code for 10 times in a row. Once I get prepared, I can go ahead and do the coding day by day. Another important thing is to keep a log. An basic log should be a record of results. For example, this time I implemented a merge sort in 03m56s correctly. To make it simple, we may use a table with 3 columns: file name, correctness and time. <br />\nResult <br />\nI absolutely benefited a lot from my KATA scheme(otherwise I would not share it with you). At the very beginning I was not able to implement any of basic algorithms I chose. The first time I struggled to do merge sort in more than 20 minutes. Now I can my best record for merge sort is 3 minutes 16 seconds. See? KATA is absolutely efficient and useful. <br />\nWeakness <br />\nKATA is great but not perfect. It is good for gaining muscle memory. I do not even need to think about the actual code when I practice because it is already there in my mind and my hands. But I have to remind you that it would be much better if you understand the algorithm fully. If you do it every day, you probably will not need to care about that. But if you stop for some time, you will not remember a thing and lose your head. So it is more important to remember the structure of the algorithm, reason every detail in code and generate your own comprehension. That will make you even more powerful. <br />\nLooking for Partner <br />\nI am doing my second round KATA on algorithms training now and am looking for someone or some guys who are interested to join me. This time I would include more common algorithms. It will not cost more than 30 minutes per day after you grasp the basic ideas and set up your own training environment. And you definitely will be deep impressed by how KATA reform your confidence on technical questions.</p>","image":null,"featured":0,"page":0,"status":"draft","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1437999390755,"created_by":1,"updated_at":1437999395594,"updated_by":1,"published_at":null,"published_by":null},{"id":10,"uuid":"41a99761-0779-4b1b-99f3-e117c623ef7a","title":"JavaScript Scope and Closure","slug":"zuo-yong-yu-yu-bi-bao-thisvarfunction-{}","markdown":"## 目标\n\n无具体目标\n\n## 知识点\n\n1. 理解 js 中 var 的作用域\n1. 了解闭包的概念\n1. 理解 this 的指向\n\n## 课程内容\n\n### var 作用域\n\n先来看个简单的例子：\n\n```js\nvar parent = function () {\n  var name = \"parent_name\";\n  var age = 13;\n\n  var child = function () {\n    var name = \"child_name\";\n    var childAge = 0.3;\n\n    // => child_name 13 0.3\n    console.log(name, age, childAge);\n  };\n\n  child();\n\n  // will throw Error\n  // ReferenceError: childAge is not defined\n  console.log(name, age, childAge);\n};\n\nparent();\n```\n\n直觉地，内部函数可以访问外部函数的变量，外部不能访问内部函数的变量。上面的例子中内部函数 child 可以访问变量 age，而外部函数 parent 不可以访问 child 中的变量 childAge，因此会抛出没有定义变量的异常。\n\n有个重要的事，如果忘记var，那么变量就被声明为全局变量了。\n\n```js\nfunction foo() {\n  value = \"hello\";\n}\nfoo();\nconsole.log(value); // 输出hello\nconsole.log(global.value) // 输出hello\n```\n\n这个例子可以很正常的输出 `hello`，是因为 `value` 变量在定义时，没有使用 `var` 关键词，所以被定义成了全局变量。在 Node 中，全局变量会被定义在 `global` 对象下；在浏览器中，全局变量会被定义在 `window` 对象下。\n\n如果你确实要定义一个全局变量的话，请显示地定义在 `global` 或者 `window` 对象上。\n\n这类不小心定义全局变量的问题可以被 jshint 检测出来，如果你使用 sublime 编辑器的话，记得装一个 `SublimeLinter` 插件，这是插件支持多语言的语法错误检测，js 的检测是原生支持的。\n\nJavaScript 中，变量的局部作用域是函数级别的。不同于 C 语言，在 C 语言中，作用域是块级别的。\nJavaScript 中没有块级作用域。\n\njs 中，函数中声明的变量在整个函数中都有定义。比如如下代码段，变量 i 和 value 虽然是在 for 循环代码块中被定义，但在代码块外仍可以访问 i 和 value。\n\n```js\nfunction foo() {\n  for (var i = 0; i < 10; i++) {\n    var value = \"hello world\";\n  }\n  console.log(i); //输出10\n  console.log(value);//输出hello world\n}\nfoo();\n```\n\n所以有种说法是：应该提前声明函数中需要用到的变量，即，在函数体的顶部声明可能用到的变量，这样就可以避免出现一些奇奇怪怪怪的 bug。\n\n但我个人不喜欢遵守这一点，一般都是现用现声明的。这类错误的检测交给 jshint 来做就好了。\n\n### 闭包\n\n闭包这个概念，在函数式编程里很常见，简单的说，就是使内部函数可以访问定义在外部函数中的变量。\n\n假如我们要实现一系列的函数：add10，add20，它们的定义是 `int add10(int n)`。\n\n为此我们构造了一个名为 adder 的构造器，如下：\n\n```js\nvar adder = function (x) {\n  var base = x;\n  return function (n) {\n    return n + base;\n  };\n};\n\nvar add10 = adder(10);\nconsole.log(add10(5));\n\nvar add20 = adder(20);\nconsole.log(add20(5));\n```\n\n每次调用 adder 时，adder 都会返回一个函数给我们。我们传给 adder 的值，会保存在一个名为 base 的变量中。由于返回的函数在其中引用了 base 的值，于是 base 的引用计数被 +1。当返回函数不被垃圾回收时，则 base 也会一直存在。\n\n我暂时想不出什么实用的例子来，如果想深入理解这块，可以看看这篇 http://coolshell.cn/articles/6731.html\n\n#### 闭包的一个坑\n\n```js\nfor (var i = 0; i < 5; i++) {\n  setTimeout(function () {\n    console.log(i);\n  }, 5);\n}\n```\n\n上面这个代码块会打印五个 `5` 出来，而我们预想的结果是打印 1 2 3 4 5。\n\n之所以会这样，是因为 setTimeout 中的 i 是对外层 i 的引用。当 setTimeout 的代码被解释的时候，运行时只是记录了 i 的引用，而不是值。而当 setTimeout 被触发时，五个 setTimeout 中的 i 同时被取值，由于它们都指向了外层的同一个 i，而那个 i 的值在迭代完成时为 5，所以打印了五次 `5`。\n\n为了得到我们预想的结果，我们可以把 i 赋值成一个局部的变量，从而摆脱外层迭代的影响。\n\n```js\nfor (var i = 0; i < 5; i++) {\n  (function (idx) {\n    setTimeout(function () {\n      console.log(idx);\n    }, 5);\n  })(i);\n}\n```\n\n### this\n\n在函数执行时，this 总是指向调用该函数的对象。要判断 this 的指向，其实就是判断 this 所在的函数属于谁。\n\n在《javaScript语言精粹》这本书中，把 this 出现的场景分为四类，简单的说就是：\n\n* 有对象就指向调用对象\n* 没调用对象就指向全局对象\n* 用new构造就指向新对象\n* 通过 apply 或 call 或 bind 来改变 this 的所指。\n\n1）函数有所属对象时：指向所属对象\n\n函数有所属对象时，通常通过 `.` 表达式调用，这时 `this` 自然指向所属对象。比如下面的例子：\n\n```js\nvar myObject = {value: 100};\nmyObject.getValue = function () {\n  console.log(this.value);  // 输出 100\n\n  // 输出 { value: 100, getValue: [Function] }，\n  // 其实就是 myObject 对象本身\n  console.log(this);\n\n  return this.value;\n};\n\nconsole.log(myObject.getValue()); // => 100\n```\n\n`getValue()` 属于对象 `myObject`，并由 `myOjbect` 进行 `.` 调用，因此 `this` 指向对象 `myObject`。\n\n2) 函数没有所属对象：指向全局对象\n\n```js\nvar myObject = {value: 100};\nmyObject.getValue = function () {\n  var foo = function () {\n    console.log(this.value) // => undefined\n    console.log(this);// 输出全局对象 global\n  };\n\n  foo();\n\n  return this.value;\n};\n\nconsole.log(myObject.getValue()); // => 100\n```\n\n在上述代码块中，`foo` 函数虽然定义在 `getValue` 的函数体内，但实际上它既不属于 `getValue` 也不属于 `myObject`。`foo` 并没有被绑定在任何对象上，所以当调用时，它的 `this` 指针指向了全局对象 `global`。\n\n据说这是个设计错误。\n\n3）构造器中的 this：指向新对象\n\njs 中，我们通过 `new` 关键词来调用构造函数，此时 this 会绑定在该新对象上。\n\n```js\n\nvar SomeClass = function(){\n  this.value = 100;\n}\n\nvar myCreate = new SomeClass();\n\nconsole.log(myCreate.value); // 输出100\n```\n\n顺便说一句，在 js 中，构造函数、普通函数、对象方法、闭包，这四者没有明确界线。界线都在人的心中。\n\n4) apply 和 call 调用以及 bind 绑定：指向绑定的对象\n\napply() 方法接受两个参数第一个是函数运行的作用域，另外一个是一个参数数组(arguments)。\n\ncall() 方法第一个参数的意义与 apply() 方法相同，只是其他的参数需要一个个列举出来。\n\n简单来说，call 的方式更接近我们平时调用函数，而 apply 需要我们传递 Array 形式的数组给它。它们是可以互相转换的。\n\n```js\nvar myObject = {value: 100};\n\nvar foo = function(){\n  console.log(this);\n};\n\nfoo(); // 全局变量 global\nfoo.apply(myObject); // { value: 100 }\nfoo.call(myObject); // { value: 100 }\n\nvar newFoo = foo.bind(myObject);\nnewFoo(); // { value: 100 }\n```\n\n完。\n\n转自 https://github.com/alsotang/node-lessons/blob/master/lesson11","html":"<h2 id=\"\">目标</h2>\n\n<p>无具体目标</p>\n\n<h2 id=\"\">知识点</h2>\n\n<ol>\n<li>理解 js 中 var 的作用域  </li>\n<li>了解闭包的概念  </li>\n<li>理解 this 的指向</li>\n</ol>\n\n<h2 id=\"\">课程内容</h2>\n\n<h3 id=\"var\">var 作用域</h3>\n\n<p>先来看个简单的例子：</p>\n\n<pre><code class=\"language-js\">var parent = function () {  \n  var name = \"parent_name\";\n  var age = 13;\n\n  var child = function () {\n    var name = \"child_name\";\n    var childAge = 0.3;\n\n    // =&gt; child_name 13 0.3\n    console.log(name, age, childAge);\n  };\n\n  child();\n\n  // will throw Error\n  // ReferenceError: childAge is not defined\n  console.log(name, age, childAge);\n};\n\nparent();  \n</code></pre>\n\n<p>直觉地，内部函数可以访问外部函数的变量，外部不能访问内部函数的变量。上面的例子中内部函数 child 可以访问变量 age，而外部函数 parent 不可以访问 child 中的变量 childAge，因此会抛出没有定义变量的异常。</p>\n\n<p>有个重要的事，如果忘记var，那么变量就被声明为全局变量了。</p>\n\n<pre><code class=\"language-js\">function foo() {  \n  value = \"hello\";\n}\nfoo();  \nconsole.log(value); // 输出hello  \nconsole.log(global.value) // 输出hello  \n</code></pre>\n\n<p>这个例子可以很正常的输出 <code>hello</code>，是因为 <code>value</code> 变量在定义时，没有使用 <code>var</code> 关键词，所以被定义成了全局变量。在 Node 中，全局变量会被定义在 <code>global</code> 对象下；在浏览器中，全局变量会被定义在 <code>window</code> 对象下。</p>\n\n<p>如果你确实要定义一个全局变量的话，请显示地定义在 <code>global</code> 或者 <code>window</code> 对象上。</p>\n\n<p>这类不小心定义全局变量的问题可以被 jshint 检测出来，如果你使用 sublime 编辑器的话，记得装一个 <code>SublimeLinter</code> 插件，这是插件支持多语言的语法错误检测，js 的检测是原生支持的。</p>\n\n<p>JavaScript 中，变量的局部作用域是函数级别的。不同于 C 语言，在 C 语言中，作用域是块级别的。 <br />\nJavaScript 中没有块级作用域。</p>\n\n<p>js 中，函数中声明的变量在整个函数中都有定义。比如如下代码段，变量 i 和 value 虽然是在 for 循环代码块中被定义，但在代码块外仍可以访问 i 和 value。</p>\n\n<pre><code class=\"language-js\">function foo() {  \n  for (var i = 0; i &lt; 10; i++) {\n    var value = \"hello world\";\n  }\n  console.log(i); //输出10\n  console.log(value);//输出hello world\n}\nfoo();  \n</code></pre>\n\n<p>所以有种说法是：应该提前声明函数中需要用到的变量，即，在函数体的顶部声明可能用到的变量，这样就可以避免出现一些奇奇怪怪怪的 bug。</p>\n\n<p>但我个人不喜欢遵守这一点，一般都是现用现声明的。这类错误的检测交给 jshint 来做就好了。</p>\n\n<h3 id=\"\">闭包</h3>\n\n<p>闭包这个概念，在函数式编程里很常见，简单的说，就是使内部函数可以访问定义在外部函数中的变量。</p>\n\n<p>假如我们要实现一系列的函数：add10，add20，它们的定义是 <code>int add10(int n)</code>。</p>\n\n<p>为此我们构造了一个名为 adder 的构造器，如下：</p>\n\n<pre><code class=\"language-js\">var adder = function (x) {  \n  var base = x;\n  return function (n) {\n    return n + base;\n  };\n};\n\nvar add10 = adder(10);  \nconsole.log(add10(5));\n\nvar add20 = adder(20);  \nconsole.log(add20(5));  \n</code></pre>\n\n<p>每次调用 adder 时，adder 都会返回一个函数给我们。我们传给 adder 的值，会保存在一个名为 base 的变量中。由于返回的函数在其中引用了 base 的值，于是 base 的引用计数被 +1。当返回函数不被垃圾回收时，则 base 也会一直存在。</p>\n\n<p>我暂时想不出什么实用的例子来，如果想深入理解这块，可以看看这篇 <a href=\"http://coolshell.cn/articles/6731.html\">http://coolshell.cn/articles/6731.html</a></p>\n\n<h4 id=\"\">闭包的一个坑</h4>\n\n<pre><code class=\"language-js\">for (var i = 0; i &lt; 5; i++) {  \n  setTimeout(function () {\n    console.log(i);\n  }, 5);\n}\n</code></pre>\n\n<p>上面这个代码块会打印五个 <code>5</code> 出来，而我们预想的结果是打印 1 2 3 4 5。</p>\n\n<p>之所以会这样，是因为 setTimeout 中的 i 是对外层 i 的引用。当 setTimeout 的代码被解释的时候，运行时只是记录了 i 的引用，而不是值。而当 setTimeout 被触发时，五个 setTimeout 中的 i 同时被取值，由于它们都指向了外层的同一个 i，而那个 i 的值在迭代完成时为 5，所以打印了五次 <code>5</code>。</p>\n\n<p>为了得到我们预想的结果，我们可以把 i 赋值成一个局部的变量，从而摆脱外层迭代的影响。</p>\n\n<pre><code class=\"language-js\">for (var i = 0; i &lt; 5; i++) {  \n  (function (idx) {\n    setTimeout(function () {\n      console.log(idx);\n    }, 5);\n  })(i);\n}\n</code></pre>\n\n<h3 id=\"this\">this</h3>\n\n<p>在函数执行时，this 总是指向调用该函数的对象。要判断 this 的指向，其实就是判断 this 所在的函数属于谁。</p>\n\n<p>在《javaScript语言精粹》这本书中，把 this 出现的场景分为四类，简单的说就是：</p>\n\n<ul>\n<li>有对象就指向调用对象</li>\n<li>没调用对象就指向全局对象</li>\n<li>用new构造就指向新对象</li>\n<li>通过 apply 或 call 或 bind 来改变 this 的所指。</li>\n</ul>\n\n<p>1）函数有所属对象时：指向所属对象</p>\n\n<p>函数有所属对象时，通常通过 <code>.</code> 表达式调用，这时 <code>this</code> 自然指向所属对象。比如下面的例子：</p>\n\n<pre><code class=\"language-js\">var myObject = {value: 100};  \nmyObject.getValue = function () {  \n  console.log(this.value);  // 输出 100\n\n  // 输出 { value: 100, getValue: [Function] }，\n  // 其实就是 myObject 对象本身\n  console.log(this);\n\n  return this.value;\n};\n\nconsole.log(myObject.getValue()); // =&gt; 100  \n</code></pre>\n\n<p><code>getValue()</code> 属于对象 <code>myObject</code>，并由 <code>myOjbect</code> 进行 <code>.</code> 调用，因此 <code>this</code> 指向对象 <code>myObject</code>。</p>\n\n<p>2) 函数没有所属对象：指向全局对象</p>\n\n<pre><code class=\"language-js\">var myObject = {value: 100};  \nmyObject.getValue = function () {  \n  var foo = function () {\n    console.log(this.value) // =&gt; undefined\n    console.log(this);// 输出全局对象 global\n  };\n\n  foo();\n\n  return this.value;\n};\n\nconsole.log(myObject.getValue()); // =&gt; 100  \n</code></pre>\n\n<p>在上述代码块中，<code>foo</code> 函数虽然定义在 <code>getValue</code> 的函数体内，但实际上它既不属于 <code>getValue</code> 也不属于 <code>myObject</code>。<code>foo</code> 并没有被绑定在任何对象上，所以当调用时，它的 <code>this</code> 指针指向了全局对象 <code>global</code>。</p>\n\n<p>据说这是个设计错误。</p>\n\n<p>3）构造器中的 this：指向新对象</p>\n\n<p>js 中，我们通过 <code>new</code> 关键词来调用构造函数，此时 this 会绑定在该新对象上。</p>\n\n<pre><code class=\"language-js\">var SomeClass = function(){  \n  this.value = 100;\n}\n\nvar myCreate = new SomeClass();\n\nconsole.log(myCreate.value); // 输出100  \n</code></pre>\n\n<p>顺便说一句，在 js 中，构造函数、普通函数、对象方法、闭包，这四者没有明确界线。界线都在人的心中。</p>\n\n<p>4) apply 和 call 调用以及 bind 绑定：指向绑定的对象</p>\n\n<p>apply() 方法接受两个参数第一个是函数运行的作用域，另外一个是一个参数数组(arguments)。</p>\n\n<p>call() 方法第一个参数的意义与 apply() 方法相同，只是其他的参数需要一个个列举出来。</p>\n\n<p>简单来说，call 的方式更接近我们平时调用函数，而 apply 需要我们传递 Array 形式的数组给它。它们是可以互相转换的。</p>\n\n<pre><code class=\"language-js\">var myObject = {value: 100};\n\nvar foo = function(){  \n  console.log(this);\n};\n\nfoo(); // 全局变量 global  \nfoo.apply(myObject); // { value: 100 }  \nfoo.call(myObject); // { value: 100 }\n\nvar newFoo = foo.bind(myObject);  \nnewFoo(); // { value: 100 }  \n</code></pre>\n\n<p>完。</p>\n\n<p>转自 <a href=\"https://github.com/alsotang/node-lessons/blob/master/lesson11\">https://github.com/alsotang/node-lessons/blob/master/lesson11</a></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1438188448711,"created_by":1,"updated_at":1438188650999,"updated_by":1,"published_at":1438188603193,"published_by":1},{"id":11,"uuid":"8069a5d7-194f-45a6-84bc-455f02d9816a","title":"Git commands cheat sheet","slug":"know-necessary-git-commands","markdown":"git init\n\ngit clone\n\ngit status\n\ngit add\n\ngit commit -m \"comments\"\n\ngit diff\n\ngit rm\n\ngit mv\n\ngit remote\n\ngit remote add <repo name>\n\ngit remote push <repo name> <brach name>\n\ngit remote rename <cur repo name> <new repo name>\ngit remote rm <repo name>\n\ngit tag \n\ngit tag -l 'v1.8.5*'\n\n\ngit tag -a v1.4 -m 'my version 1.4'\n\ngit push origin [tagname]\n\ngit push origin --tags\n\ngit checkout -b version2 v2.0.0\n","html":"<p>git init</p>\n\n<p>git clone</p>\n\n<p>git status</p>\n\n<p>git add</p>\n\n<p>git commit -m \"comments\"</p>\n\n<p>git diff</p>\n\n<p>git rm</p>\n\n<p>git mv</p>\n\n<p>git remote</p>\n\n<p>git remote add <repo name></p>\n\n<p>git remote push <repo name> <brach name></p>\n\n<p>git remote rename <cur repo name> <new repo name> <br />\ngit remote rm <repo name></p>\n\n<p>git tag </p>\n\n<p>git tag -l 'v1.8.5*'</p>\n\n<p>git tag -a v1.4 -m 'my version 1.4'</p>\n\n<p>git push origin [tagname]</p>\n\n<p>git push origin --tags</p>\n\n<p>git checkout -b version2 v2.0.0</p>","image":null,"featured":0,"page":0,"status":"draft","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1447706300322,"created_by":1,"updated_at":1447707612685,"updated_by":1,"published_at":null,"published_by":null},{"id":12,"uuid":"916dcb4d-2f8b-4b09-95c4-dc8f208be188","title":"Angular 2 and Angular 1.x major difference","slug":"angular-2","markdown":"######Introduce\nAngular团队面临着这样的问题：如何在不影响1.x版本使用的情况下谈论很多2.0的高级新功能。这就是奥斯本效应，上个世纪80年代的电脑公司，终因市场源于而歇业后命名。简而言之，2.0版本听起来越好，就越少有人去使用1.x版本。不同的是，Angular 2.0版本已经可以从github上通过npm install angular@2.0.0-alpha.6 得到它了。但是，这个不能用于生产，它还在被大量的修改。\n\n######Angular 1.x vs. 2.0\n为什么Angular团队会做出如此大得变化的原因是什么呢。Angular不只是试图跟上，他们还推动了大量的标准的应用，增强了现有的应用架构。\n\n######双向数据绑定\n2.0 单向数据绑定\n\n在大型项目中，双向数据绑定会被使用的像意大利面条一样。Angular 2.0引入了无回路有向图的单向结构概念。\n\n这听起来很像React的Flux所做的工作。这种结构也可以被Angular来使用。\n\n虽然双向绑定会消失，Angular创始人Misko已经声明：2.0中会有方法实现双向绑定，虽然实现的背后数据是单向的。\n\n######观察器\n2.0：Zone.js\n\n$scope.$watch, $scope.$apply, $timeout这些都不在需要了，这也是1.x版本有如此之大的学习曲线的原因。\n\nZone.js可以帮Angular实现变化的自动检测。这听起来很像React的差异比较算法。\n\nAngular团队解释道，现在的变化检测更快了，内存更小了，同时也更加强大了。变化检测的性能可能随着将来的object.observe的到来而有更大的提升。\n\nZone.js同时支持不变对象，这样检测的速度上会有更大的提升。这是因为编译器会认为数据对象不会变化从而进行优化。\n\n######组件通信\n2.0：除了$broadcast 和 $emit，2.0还有一些小得变化，1）你可以在DOM层发送消息，而不是在scope；2）你可以组件嵌套，然后link他们，这看上去很像每个组件都使用它们独立的scope。\n\n######DOM\n2.0：从很多方面可以看出，Angular 2.0对于DOM样式的操作很像React的virtual DOM，它引用的是最近呈现的view层。关于Angular Native，Misko提到，这个view层可以运行于web worker，甚至是native。\n\n######scope\n数据将会被组织成树形结构\n\nAngular 2.0也会使用web组件标准。比如，shadow DOM可以用来创建独立的scope。Angular团队解释到，2.0会有一个shadow DOM模拟模块（当前浏览器还不支持web组件），这将给独立css提供新的选择，很酷不是么！\n\n######模块\n2.0：2.0将肯定使用ES6的模块语法。同时，2.0还希望通过懒加载来引入依赖注入。和以往通过单例方式管理不同的是，2.0希望使用一种层次化数据结构来提供继承特性。你将能够控制模块的生命周期，比如services。\n\n######指令\n2.0：现在将被成为“组件”。在1.x版本中，指令在大型项目解决冲突中随处可见。但是在2.0中，你必须导入你的组件才能去解决初始化中得命名空间冲突问题。虽然我不明白它是如何工作的，但是2.0将会创建一个原型模板用于潜在的绑定以优化编译器速度。\n\n######Router\n2.0:虽然没有1.x里面不稳定的懒加载特性，但看上去应该是从1.x版本移植过来的。\n\nBrian Ford发了一篇关于新路由的介绍，值得我们关注下。他描述了一个新的路由如何能够同时工作于1.x和2.x版本，这就允许团队逐渐的过度到新的版本中。他同时建议使用当前流行的ui-router来迁移地址。Ui-router很不错，但是缺少一些重要的特性。比如，解析只能在页面加载之后才能传递参数。但是如果你想在到下个页面之前去校验form表单中当前的数据咋办呢？Ui-routers的解析是一次性触发的。相反，新的router会提供一个钩子，允许你在制定地方做一些你想要的动作。\n\n######HTML\n2.0：虽然语法看上去有些不一样，但是记住，在这背后肯定是有一定好的原因的。\n\n######ng-指令\nHTML中得组件被拆分魏两种类型：(事件)和[属性]。他们被包装在圆括号和中括号中，这样肉眼和机器都能识别了，从而可以优化这两种类型。\n\n######(事件)\n\n(事件) 用于初始化动作.\n```js\n1.x             2.0\nng-click       (click) (dbl-click)\nng-keyup       (keyup)\n```\n######[属性]\n\n[属性] 直接链接到DOM属性中.\n```js\n1.x               2.0\nng-hide        [class:hidden]\nng-checked     [checked]\n```\n######!foreach\n!foreach 是用来取代 ng-repeat.\n```js\n<ul>  \n<li !foreach=\"#item in itemService.items\"></li>  \n</ul>  \n```\n#######item\n对象的属性加上 # 就可以直接绑定在html上。\n```js\n<input type=\"text\" #userName />  \n```\n######{{ }}\n双大括号在2.0依然可见。看，不是啥都在变化。\n\n######组件名称\n不会再出现骆驼命名和蛇命名混淆的情况了。现在你必须自己制定组件中得指令名称。由于Angular 2.0符合web组件标准，它需要-来链接名字。\n```js\n@Component {\n    selector: 'myApp-component'\n}\n```\n######总结\nAngular 2.0版本看起来有点不可思议的。虽然还没有完全可用于生产，但是你可以玩一玩了。可以在github上下载到。同时也有一些例子，比如ng2do。\n\n如果你像降低学习曲线，那你现在可以做如下事情：\n\n尝试看Rob Eisenbergs的新框架：Aurelia。毫无疑问，非常值得看，从中可以学到很多关于web组件和shadow DOM的事情。\n\n在Angular1.x中使用ES6-(现在可能是ES2015)。这里有很多例子关于ES6和JSPM。\n\n多多学习Facebook的React.js。很多伟大的理念都是从这里传播出去的，比如Flux。\n\n放眼一看，Angular1和2两个版本的共同点很少。2.0版本看起来是要做彻底的改变。因此有必要抽点时间去研究下心的框架，从而可以快速的成为专家。","html":"<h6 id=\"introduce\">Introduce</h6>\n\n<p>Angular团队面临着这样的问题：如何在不影响1.x版本使用的情况下谈论很多2.0的高级新功能。这就是奥斯本效应，上个世纪80年代的电脑公司，终因市场源于而歇业后命名。简而言之，2.0版本听起来越好，就越少有人去使用1.x版本。不同的是，Angular 2.0版本已经可以从github上通过npm install angular@2.0.0-alpha.6 得到它了。但是，这个不能用于生产，它还在被大量的修改。</p>\n\n<h6 id=\"angular1xvs20\">Angular 1.x vs. 2.0</h6>\n\n<p>为什么Angular团队会做出如此大得变化的原因是什么呢。Angular不只是试图跟上，他们还推动了大量的标准的应用，增强了现有的应用架构。</p>\n\n<h6 id=\"\">双向数据绑定</h6>\n\n<p>2.0 单向数据绑定</p>\n\n<p>在大型项目中，双向数据绑定会被使用的像意大利面条一样。Angular 2.0引入了无回路有向图的单向结构概念。</p>\n\n<p>这听起来很像React的Flux所做的工作。这种结构也可以被Angular来使用。</p>\n\n<p>虽然双向绑定会消失，Angular创始人Misko已经声明：2.0中会有方法实现双向绑定，虽然实现的背后数据是单向的。</p>\n\n<h6 id=\"\">观察器</h6>\n\n<p>2.0：Zone.js</p>\n\n<p>$scope.$watch, $scope.$apply, $timeout这些都不在需要了，这也是1.x版本有如此之大的学习曲线的原因。</p>\n\n<p>Zone.js可以帮Angular实现变化的自动检测。这听起来很像React的差异比较算法。</p>\n\n<p>Angular团队解释道，现在的变化检测更快了，内存更小了，同时也更加强大了。变化检测的性能可能随着将来的object.observe的到来而有更大的提升。</p>\n\n<p>Zone.js同时支持不变对象，这样检测的速度上会有更大的提升。这是因为编译器会认为数据对象不会变化从而进行优化。</p>\n\n<h6 id=\"\">组件通信</h6>\n\n<p>2.0：除了$broadcast 和 $emit，2.0还有一些小得变化，1）你可以在DOM层发送消息，而不是在scope；2）你可以组件嵌套，然后link他们，这看上去很像每个组件都使用它们独立的scope。</p>\n\n<h6 id=\"dom\">DOM</h6>\n\n<p>2.0：从很多方面可以看出，Angular 2.0对于DOM样式的操作很像React的virtual DOM，它引用的是最近呈现的view层。关于Angular Native，Misko提到，这个view层可以运行于web worker，甚至是native。</p>\n\n<h6 id=\"scope\">scope</h6>\n\n<p>数据将会被组织成树形结构</p>\n\n<p>Angular 2.0也会使用web组件标准。比如，shadow DOM可以用来创建独立的scope。Angular团队解释到，2.0会有一个shadow DOM模拟模块（当前浏览器还不支持web组件），这将给独立css提供新的选择，很酷不是么！</p>\n\n<h6 id=\"\">模块</h6>\n\n<p>2.0：2.0将肯定使用ES6的模块语法。同时，2.0还希望通过懒加载来引入依赖注入。和以往通过单例方式管理不同的是，2.0希望使用一种层次化数据结构来提供继承特性。你将能够控制模块的生命周期，比如services。</p>\n\n<h6 id=\"\">指令</h6>\n\n<p>2.0：现在将被成为“组件”。在1.x版本中，指令在大型项目解决冲突中随处可见。但是在2.0中，你必须导入你的组件才能去解决初始化中得命名空间冲突问题。虽然我不明白它是如何工作的，但是2.0将会创建一个原型模板用于潜在的绑定以优化编译器速度。</p>\n\n<h6 id=\"router\">Router</h6>\n\n<p>2.0:虽然没有1.x里面不稳定的懒加载特性，但看上去应该是从1.x版本移植过来的。</p>\n\n<p>Brian Ford发了一篇关于新路由的介绍，值得我们关注下。他描述了一个新的路由如何能够同时工作于1.x和2.x版本，这就允许团队逐渐的过度到新的版本中。他同时建议使用当前流行的ui-router来迁移地址。Ui-router很不错，但是缺少一些重要的特性。比如，解析只能在页面加载之后才能传递参数。但是如果你想在到下个页面之前去校验form表单中当前的数据咋办呢？Ui-routers的解析是一次性触发的。相反，新的router会提供一个钩子，允许你在制定地方做一些你想要的动作。</p>\n\n<h6 id=\"html\">HTML</h6>\n\n<p>2.0：虽然语法看上去有些不一样，但是记住，在这背后肯定是有一定好的原因的。</p>\n\n<h6 id=\"ng\">ng-指令</h6>\n\n<p>HTML中得组件被拆分魏两种类型：(事件)和[属性]。他们被包装在圆括号和中括号中，这样肉眼和机器都能识别了，从而可以优化这两种类型。</p>\n\n<h6 id=\"\">(事件)</h6>\n\n<p>(事件) 用于初始化动作.</p>\n\n<pre><code class=\"language-js\">1.x             2.0  \nng-click       (click) (dbl-click)  \nng-keyup       (keyup)  \n</code></pre>\n\n<h6 id=\"\">[属性]</h6>\n\n<p>[属性] 直接链接到DOM属性中.</p>\n\n<pre><code class=\"language-js\">1.x               2.0  \nng-hide        [class:hidden]  \nng-checked     [checked]  \n</code></pre>\n\n<h6 id=\"foreach\">!foreach</h6>\n\n<p>!foreach 是用来取代 ng-repeat.</p>\n\n<pre><code class=\"language-js\">&lt;ul&gt;  \n&lt;li !foreach=\"#item in itemService.items\"&gt;&lt;/li&gt;  \n&lt;/ul&gt;  \n</code></pre>\n\n<h6 id=\"item\">#item</h6>\n\n<p>对象的属性加上 # 就可以直接绑定在html上。</p>\n\n<pre><code class=\"language-js\">&lt;input type=\"text\" #userName /&gt;  \n</code></pre>\n\n<h6 id=\"\">{{ }}</h6>\n\n<p>双大括号在2.0依然可见。看，不是啥都在变化。</p>\n\n<h6 id=\"\">组件名称</h6>\n\n<p>不会再出现骆驼命名和蛇命名混淆的情况了。现在你必须自己制定组件中得指令名称。由于Angular 2.0符合web组件标准，它需要-来链接名字。</p>\n\n<pre><code class=\"language-js\">@Component {\n    selector: 'myApp-component'\n}\n</code></pre>\n\n<h6 id=\"\">总结</h6>\n\n<p>Angular 2.0版本看起来有点不可思议的。虽然还没有完全可用于生产，但是你可以玩一玩了。可以在github上下载到。同时也有一些例子，比如ng2do。</p>\n\n<p>如果你像降低学习曲线，那你现在可以做如下事情：</p>\n\n<p>尝试看Rob Eisenbergs的新框架：Aurelia。毫无疑问，非常值得看，从中可以学到很多关于web组件和shadow DOM的事情。</p>\n\n<p>在Angular1.x中使用ES6-(现在可能是ES2015)。这里有很多例子关于ES6和JSPM。</p>\n\n<p>多多学习Facebook的React.js。很多伟大的理念都是从这里传播出去的，比如Flux。</p>\n\n<p>放眼一看，Angular1和2两个版本的共同点很少。2.0版本看起来是要做彻底的改变。因此有必要抽点时间去研究下心的框架，从而可以快速的成为专家。</p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1457840316908,"created_by":1,"updated_at":1457840811002,"updated_by":1,"published_at":1457840811005,"published_by":1},{"id":13,"uuid":"267c03c5-cd9d-41ab-9d4f-cff9e91b4040","title":"Debug Node JS by node-inspector","slug":"debug-node-js-by-node-inspector","markdown":"First, you have to install node-inspector package from NPM\n```\nnpm install -g node-inspector\n```\n\nRun node inspector before starting your node application, Node-inspector monitor your node application between Browser and your application thru Websocket. You have to specify a web port number for it.\n\n\n![run node-inspector](/content/images/2016/03/1.png)\n\n\n\nAdd --debug when you start your node application\n```\nnode --debug app.js\n```\n![debug node app](/content/images/2016/03/2-2.png)\n\nOnce your Node APP is running, put the following URL into your browser. Enjoy your fights with bugs\n```\nhttp://127.0.0.1:8888/debug?port=5858\n```\n![debug node app](/content/images/2016/03/3.png)\n\n","html":"<p>First, you have to install node-inspector package from NPM  </p>\n\n<pre><code>npm install -g node-inspector  \n</code></pre>\n\n<p>Run node inspector before starting your node application, Node-inspector monitor your node application between Browser and your application thru Websocket. You have to specify a web port number for it.</p>\n\n<p><img src=\"/content/images/2016/03/1.png\" alt=\"run node-inspector\" /></p>\n\n<p>Add --debug when you start your node application  </p>\n\n<pre><code>node --debug app.js  \n</code></pre>\n\n<p><img src=\"/content/images/2016/03/2-2.png\" alt=\"debug node app\" /></p>\n\n<p>Once your Node APP is running, put the following URL into your browser. Enjoy your fights with bugs  </p>\n\n<pre><code>http://127.0.0.1:8888/debug?port=5858  \n</code></pre>\n\n<p><img src=\"/content/images/2016/03/3.png\" alt=\"debug node app\" /></p>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1458929377714,"created_by":1,"updated_at":1458930200862,"updated_by":1,"published_at":1458930200863,"published_by":1},{"id":14,"uuid":"84bbd700-a0a0-4715-a74b-93fbdb37c01d","title":"(Untitled)","slug":"untitled-2","markdown":"AngularJS\n\nBetter CoffeeScript\n\nTypeScript\n\nJsFormat\n\nTerminal\n\nSideBar\n\nSublimeCodeIntel\n\njshint\nsublimelinter","html":"<p>AngularJS</p>\n\n<p>Better CoffeeScript</p>\n\n<p>TypeScript</p>\n\n<p>JsFormat</p>\n\n<p>Terminal</p>\n\n<p>SideBar</p>\n\n<p>SublimeCodeIntel</p>\n\n<p>jshint <br />\nsublimelinter</p>","image":null,"featured":0,"page":0,"status":"draft","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1460080633621,"created_by":1,"updated_at":1460081057039,"updated_by":1,"published_at":null,"published_by":null},{"id":15,"uuid":"927d5629-1ecf-4f88-a31a-55ae31dd2dc7","title":"Node JS with express-jwt example","slug":"node-js-jwt-web-app","markdown":"###JWT package\n* express-jwt\n* jsonwebtoken\n\n######Step 1,\nClient side sends the login request to server with ID and password.\n\n######Step 2,\nIf server side verified ID and password successfully, it will return the signed jwt token to client, and also store the jwt token to Redis or DB for further verification. \n```js\nvar jwt = require('jsonwebtoken');\nvar secretToken = 'aMdoeb5ed87zorRdkD6greDML81DcnrzeSD648ferFejmplx';\nvar token = jwt.sign({id: user._id}, secretToken, { expiresInMinutes: tokenManager.TOKEN_EXPIRATION });\nreturn res.json({token:token});\n```\n\n######Step 3,\nWhen Client Side gets the login response with token, it should store the jwt token to client side(localStorage) and send the token for every future request, Suggest to use client side interceptor to do the job.\nAngularJS Example, \n```js\nappServices.factory('TokenInterceptor', function ($q, $window, $location, AuthenticationService) {\n    return {\n        request: function (config) {\n            config.headers = config.headers || {};\n            if ($window.sessionStorage.token) {\n                config.headers.Authorization = 'Bearer ' + $window.sessionStorage.token;\n            }\n            return config;\n        }\n}\n\napp.config(function ($httpProvider) {\n    $httpProvider.interceptors.push('TokenInterceptor');\n});\n```\n\n######Step 4,\nFor every request which needs be authorized, we add jwt (express-jwt) middleware for the request, jwt middleware will put decoded token in req.user for each request if the token is verified(can be decoded by secret), then we can verify the value in the req.user to see if it matches the token we generated/stored in step 1.\n```js\nvar jwt = require('express-jwt');\napp.get('/post/create', jwt({secret:secretToken}), routes.users.care); \n```\n","html":"<h3 id=\"jwtpackage\">JWT package</h3>\n\n<ul>\n<li>express-jwt</li>\n<li>jsonwebtoken</li>\n</ul>\n\n<h6 id=\"step1\">Step 1,</h6>\n\n<p>Client side sends the login request to server with ID and password.</p>\n\n<h6 id=\"step2\">Step 2,</h6>\n\n<p>If server side verified ID and password successfully, it will return the signed jwt token to client, and also store the jwt token to Redis or DB for further verification.  </p>\n\n<pre><code class=\"language-js\">var jwt = require('jsonwebtoken');  \nvar secretToken = 'aMdoeb5ed87zorRdkD6greDML81DcnrzeSD648ferFejmplx';  \nvar token = jwt.sign({id: user._id}, secretToken, { expiresInMinutes: tokenManager.TOKEN_EXPIRATION });  \nreturn res.json({token:token});  \n</code></pre>\n\n<h6 id=\"step3\">Step 3,</h6>\n\n<p>When Client Side gets the login response with token, it should store the jwt token to client side(localStorage) and send the token for every future request, Suggest to use client side interceptor to do the job. <br />\nAngularJS Example,  </p>\n\n<pre><code class=\"language-js\">appServices.factory('TokenInterceptor', function ($q, $window, $location, AuthenticationService) {  \n    return {\n        request: function (config) {\n            config.headers = config.headers || {};\n            if ($window.sessionStorage.token) {\n                config.headers.Authorization = 'Bearer ' + $window.sessionStorage.token;\n            }\n            return config;\n        }\n}\n\napp.config(function ($httpProvider) {  \n    $httpProvider.interceptors.push('TokenInterceptor');\n});\n</code></pre>\n\n<h6 id=\"step4\">Step 4,</h6>\n\n<p>For every request which needs be authorized, we add jwt (express-jwt) middleware for the request, jwt middleware will put decoded token in req.user for each request if the token is verified(can be decoded by secret), then we can verify the value in the req.user to see if it matches the token we generated/stored in step 1.  </p>\n\n<pre><code class=\"language-js\">var jwt = require('express-jwt');  \napp.get('/post/create', jwt({secret:secretToken}), routes.users.care);  \n</code></pre>","image":null,"featured":0,"page":0,"status":"published","language":"en_US","meta_title":null,"meta_description":null,"author_id":1,"created_at":1463772320636,"created_by":1,"updated_at":1463773773411,"updated_by":1,"published_at":1463773268533,"published_by":1}],"users":[{"id":1,"uuid":"ba14f49b-f45a-44ce-8599-7f071b15b449","name":"mxia","slug":"mxia","password":"$2a$10$Uuf.MAIR57bxNIG5uOWb.uCPtLc5EHLqh5CNfIL/qpVMdSdH1lzSi","email":"mxiamxia@gmail.com","image":null,"cover":null,"bio":null,"website":null,"location":null,"accessibility":null,"status":"active","language":"en_US","meta_title":null,"meta_description":null,"last_login":1463772290935,"created_at":1431565269283,"created_by":1,"updated_at":1463772290935,"updated_by":1}],"roles":[{"id":1,"uuid":"9405b7e3-2ac6-4e1b-9fea-6cfebf00a362","name":"Administrator","description":"Administrators","created_at":1431565266697,"created_by":1,"updated_at":1431565266697,"updated_by":1},{"id":2,"uuid":"8d42b3db-419c-43ff-b3cc-b4000fc96577","name":"Editor","description":"Editors","created_at":1431565266697,"created_by":1,"updated_at":1431565266697,"updated_by":1},{"id":3,"uuid":"575a7740-1a6f-418f-a064-ba4c4c8474d0","name":"Author","description":"Authors","created_at":1431565266698,"created_by":1,"updated_at":1431565266698,"updated_by":1},{"id":4,"uuid":"ef3b583d-a84f-47e0-b74d-311ffefc27a7","name":"Owner","description":"Blog Owner","created_at":1431565266698,"created_by":1,"updated_at":1431565266698,"updated_by":1}],"roles_users":[{"id":1,"role_id":4,"user_id":1}],"permissions":[{"id":1,"uuid":"8c03e777-a153-4e85-89df-1c32ddb9d0e5","name":"Export database","object_type":"db","action_type":"exportContent","object_id":null,"created_at":1431565268310,"created_by":1,"updated_at":1431565268310,"updated_by":1},{"id":2,"uuid":"7509c8d1-d619-4b34-9cfe-79fe0e089509","name":"Import database","object_type":"db","action_type":"importContent","object_id":null,"created_at":1431565268320,"created_by":1,"updated_at":1431565268320,"updated_by":1},{"id":3,"uuid":"16bd693b-91f2-45a4-a278-e5d3c7ee9ffa","name":"Delete all content","object_type":"db","action_type":"deleteAllContent","object_id":null,"created_at":1431565268329,"created_by":1,"updated_at":1431565268329,"updated_by":1},{"id":4,"uuid":"6323534a-4dba-4474-8bcd-8d741ae7dc64","name":"Send mail","object_type":"mail","action_type":"send","object_id":null,"created_at":1431565268340,"created_by":1,"updated_at":1431565268340,"updated_by":1},{"id":5,"uuid":"9cdddb5b-5927-4aa7-84b0-76a056bc4db5","name":"Browse notifications","object_type":"notification","action_type":"browse","object_id":null,"created_at":1431565268346,"created_by":1,"updated_at":1431565268346,"updated_by":1},{"id":6,"uuid":"d802ea39-d614-470a-a1ed-fd2f89f8b65c","name":"Add notifications","object_type":"notification","action_type":"add","object_id":null,"created_at":1431565268353,"created_by":1,"updated_at":1431565268353,"updated_by":1},{"id":7,"uuid":"188657a8-0b0c-4003-a86c-c05033e3d0d9","name":"Delete notifications","object_type":"notification","action_type":"destroy","object_id":null,"created_at":1431565268365,"created_by":1,"updated_at":1431565268365,"updated_by":1},{"id":8,"uuid":"ed1c534e-5fad-4eef-889c-447854fb74b0","name":"Browse posts","object_type":"post","action_type":"browse","object_id":null,"created_at":1431565268375,"created_by":1,"updated_at":1431565268375,"updated_by":1},{"id":9,"uuid":"9cad7c29-c282-4f4d-8123-6053ac69e54c","name":"Read posts","object_type":"post","action_type":"read","object_id":null,"created_at":1431565268388,"created_by":1,"updated_at":1431565268388,"updated_by":1},{"id":10,"uuid":"932b04bd-e7ca-44cf-9341-27ac80edc245","name":"Edit posts","object_type":"post","action_type":"edit","object_id":null,"created_at":1431565268397,"created_by":1,"updated_at":1431565268397,"updated_by":1},{"id":11,"uuid":"598e826c-7af8-453e-96da-d613707992ef","name":"Add posts","object_type":"post","action_type":"add","object_id":null,"created_at":1431565268408,"created_by":1,"updated_at":1431565268408,"updated_by":1},{"id":12,"uuid":"1a4ad949-2b49-456d-b05c-7cc6361361b7","name":"Delete posts","object_type":"post","action_type":"destroy","object_id":null,"created_at":1431565268419,"created_by":1,"updated_at":1431565268419,"updated_by":1},{"id":13,"uuid":"4b75189a-9956-493e-abd6-908d3c87e9a4","name":"Browse settings","object_type":"setting","action_type":"browse","object_id":null,"created_at":1431565268423,"created_by":1,"updated_at":1431565268423,"updated_by":1},{"id":14,"uuid":"d8b0c142-e154-4c00-8bc4-39e164c8a025","name":"Read settings","object_type":"setting","action_type":"read","object_id":null,"created_at":1431565268426,"created_by":1,"updated_at":1431565268426,"updated_by":1},{"id":15,"uuid":"9adf6ce0-34c7-4907-b672-5c2cc5c2ed54","name":"Edit settings","object_type":"setting","action_type":"edit","object_id":null,"created_at":1431565268431,"created_by":1,"updated_at":1431565268431,"updated_by":1},{"id":16,"uuid":"5ef32bf5-6c1f-48e9-952c-53b3d72aaf38","name":"Generate slugs","object_type":"slug","action_type":"generate","object_id":null,"created_at":1431565268440,"created_by":1,"updated_at":1431565268440,"updated_by":1},{"id":17,"uuid":"559b4f35-079e-4d2b-be18-7a0cd3446c9c","name":"Browse tags","object_type":"tag","action_type":"browse","object_id":null,"created_at":1431565268444,"created_by":1,"updated_at":1431565268444,"updated_by":1},{"id":18,"uuid":"5cf8663c-8ec4-4358-970a-3a17909c96fb","name":"Read tags","object_type":"tag","action_type":"read","object_id":null,"created_at":1431565268457,"created_by":1,"updated_at":1431565268457,"updated_by":1},{"id":19,"uuid":"e53c4ff4-3e22-44c1-880d-b2f8593a47cf","name":"Edit tags","object_type":"tag","action_type":"edit","object_id":null,"created_at":1431565268461,"created_by":1,"updated_at":1431565268461,"updated_by":1},{"id":20,"uuid":"47063e80-09a4-4903-bb5b-6ba1bbf775d7","name":"Add tags","object_type":"tag","action_type":"add","object_id":null,"created_at":1431565268470,"created_by":1,"updated_at":1431565268470,"updated_by":1},{"id":21,"uuid":"29ff5643-8f43-4999-97b5-cf2a0b9147cc","name":"Delete tags","object_type":"tag","action_type":"destroy","object_id":null,"created_at":1431565268474,"created_by":1,"updated_at":1431565268474,"updated_by":1},{"id":22,"uuid":"f213d623-14a0-4b27-b4f3-29e2e0746b1b","name":"Browse themes","object_type":"theme","action_type":"browse","object_id":null,"created_at":1431565268477,"created_by":1,"updated_at":1431565268477,"updated_by":1},{"id":23,"uuid":"35799a4f-abc8-4fe6-82c2-d05584583874","name":"Edit themes","object_type":"theme","action_type":"edit","object_id":null,"created_at":1431565268481,"created_by":1,"updated_at":1431565268481,"updated_by":1},{"id":24,"uuid":"ddfb25a9-93cf-4c7a-9e61-1586a64417c3","name":"Browse users","object_type":"user","action_type":"browse","object_id":null,"created_at":1431565268486,"created_by":1,"updated_at":1431565268486,"updated_by":1},{"id":25,"uuid":"03bf1972-f42e-4e60-94ed-ee6570e630bc","name":"Read users","object_type":"user","action_type":"read","object_id":null,"created_at":1431565268490,"created_by":1,"updated_at":1431565268490,"updated_by":1},{"id":26,"uuid":"180a9bba-d625-43e6-b8ea-5a928fc049aa","name":"Edit users","object_type":"user","action_type":"edit","object_id":null,"created_at":1431565268495,"created_by":1,"updated_at":1431565268495,"updated_by":1},{"id":27,"uuid":"eaee77ed-990a-412a-87ef-279a5934a545","name":"Add users","object_type":"user","action_type":"add","object_id":null,"created_at":1431565268510,"created_by":1,"updated_at":1431565268510,"updated_by":1},{"id":28,"uuid":"9f0f8051-bff5-4b74-a644-c49036dedd56","name":"Delete users","object_type":"user","action_type":"destroy","object_id":null,"created_at":1431565268514,"created_by":1,"updated_at":1431565268514,"updated_by":1},{"id":29,"uuid":"97aa1a5d-4865-4295-836a-c7931db3f758","name":"Assign a role","object_type":"role","action_type":"assign","object_id":null,"created_at":1431565268518,"created_by":1,"updated_at":1431565268518,"updated_by":1},{"id":30,"uuid":"1e03cb5f-588c-49b1-9a11-cec095419b61","name":"Browse roles","object_type":"role","action_type":"browse","object_id":null,"created_at":1431565268521,"created_by":1,"updated_at":1431565268521,"updated_by":1}],"permissions_users":[],"permissions_roles":[{"id":1,"role_id":1,"permission_id":1},{"id":2,"role_id":1,"permission_id":2},{"id":3,"role_id":1,"permission_id":3},{"id":4,"role_id":1,"permission_id":4},{"id":5,"role_id":1,"permission_id":5},{"id":6,"role_id":1,"permission_id":6},{"id":7,"role_id":1,"permission_id":7},{"id":8,"role_id":1,"permission_id":8},{"id":9,"role_id":1,"permission_id":9},{"id":10,"role_id":1,"permission_id":10},{"id":11,"role_id":1,"permission_id":11},{"id":12,"role_id":1,"permission_id":12},{"id":13,"role_id":1,"permission_id":13},{"id":14,"role_id":1,"permission_id":14},{"id":15,"role_id":1,"permission_id":15},{"id":16,"role_id":1,"permission_id":16},{"id":17,"role_id":1,"permission_id":17},{"id":18,"role_id":1,"permission_id":18},{"id":19,"role_id":1,"permission_id":19},{"id":20,"role_id":1,"permission_id":20},{"id":21,"role_id":1,"permission_id":21},{"id":22,"role_id":1,"permission_id":22},{"id":23,"role_id":1,"permission_id":23},{"id":24,"role_id":1,"permission_id":24},{"id":25,"role_id":1,"permission_id":25},{"id":26,"role_id":1,"permission_id":26},{"id":27,"role_id":1,"permission_id":27},{"id":28,"role_id":1,"permission_id":28},{"id":29,"role_id":1,"permission_id":29},{"id":30,"role_id":1,"permission_id":30},{"id":31,"role_id":2,"permission_id":8},{"id":32,"role_id":2,"permission_id":9},{"id":33,"role_id":2,"permission_id":10},{"id":34,"role_id":2,"permission_id":11},{"id":35,"role_id":2,"permission_id":12},{"id":36,"role_id":2,"permission_id":13},{"id":37,"role_id":2,"permission_id":14},{"id":38,"role_id":2,"permission_id":16},{"id":39,"role_id":2,"permission_id":17},{"id":40,"role_id":2,"permission_id":18},{"id":41,"role_id":2,"permission_id":19},{"id":42,"role_id":2,"permission_id":20},{"id":43,"role_id":2,"permission_id":21},{"id":44,"role_id":2,"permission_id":24},{"id":45,"role_id":2,"permission_id":25},{"id":46,"role_id":2,"permission_id":26},{"id":47,"role_id":2,"permission_id":27},{"id":48,"role_id":2,"permission_id":28},{"id":49,"role_id":2,"permission_id":29},{"id":50,"role_id":2,"permission_id":30},{"id":51,"role_id":3,"permission_id":8},{"id":52,"role_id":3,"permission_id":9},{"id":53,"role_id":3,"permission_id":11},{"id":54,"role_id":3,"permission_id":13},{"id":55,"role_id":3,"permission_id":14},{"id":56,"role_id":3,"permission_id":16},{"id":57,"role_id":3,"permission_id":17},{"id":58,"role_id":3,"permission_id":18},{"id":59,"role_id":3,"permission_id":20},{"id":60,"role_id":3,"permission_id":24},{"id":61,"role_id":3,"permission_id":25},{"id":62,"role_id":3,"permission_id":30}],"permissions_apps":[],"settings":[{"id":1,"uuid":"d12e4bdb-a1cf-47f8-b1d3-bb1378be469c","key":"databaseVersion","value":"003","type":"core","created_at":1431565269302,"created_by":1,"updated_at":1431565269302,"updated_by":1},{"id":2,"uuid":"7e1606a6-2085-48bd-90a6-220568b6d194","key":"dbHash","value":"97195874-89e0-4189-a036-a14f49e66ef9","type":"core","created_at":1431565269322,"created_by":1,"updated_at":1431565269522,"updated_by":1},{"id":3,"uuid":"c1ae9f5b-0ea4-4df9-928c-28252d0aca71","key":"nextUpdateCheck","value":"1463858676","type":"core","created_at":1431565269323,"created_by":1,"updated_at":1463772278034,"updated_by":1},{"id":4,"uuid":"9dcbe62d-22d9-404d-8da1-acae9127e2f8","key":"displayUpdateNotification","value":"0.5.0","type":"core","created_at":1431565269324,"created_by":1,"updated_at":1463772278044,"updated_by":1},{"id":5,"uuid":"bf25552c-a901-4aa4-9cd3-b620eb8bdb0c","key":"title","value":"Tech and Life","type":"blog","created_at":1431565269327,"created_by":1,"updated_at":1433865289297,"updated_by":1},{"id":6,"uuid":"c10a1aa5-1748-4fc8-8087-17e92abc99ea","key":"description","value":"Thoughts, stories and ideas.","type":"blog","created_at":1431565269328,"created_by":1,"updated_at":1433865289298,"updated_by":1},{"id":7,"uuid":"a919f693-7600-4f8b-a09e-8029222a6e60","key":"email","value":"mxiamxia@gmail.com","type":"blog","created_at":1431565269329,"created_by":1,"updated_at":1433865289299,"updated_by":1},{"id":8,"uuid":"91c14017-3d0c-43aa-b6c2-be320d0f6e1b","key":"logo","value":"","type":"blog","created_at":1431565269330,"created_by":1,"updated_at":1433865289324,"updated_by":1},{"id":9,"uuid":"e3e9d4f4-98a6-4997-8758-9ce819837b91","key":"cover","value":"","type":"blog","created_at":1431565269330,"created_by":1,"updated_at":1433865289326,"updated_by":1},{"id":10,"uuid":"0d07767d-497e-466c-abdf-81939f4e11c9","key":"defaultLang","value":"en_US","type":"blog","created_at":1431565269331,"created_by":1,"updated_at":1433865289327,"updated_by":1},{"id":11,"uuid":"872d910f-b9c8-4155-8f7d-b880e1606be5","key":"postsPerPage","value":"5","type":"blog","created_at":1431565269332,"created_by":1,"updated_at":1433865289328,"updated_by":1},{"id":12,"uuid":"1d936ebe-8bdd-45e9-bf60-9d7f90b5a226","key":"forceI18n","value":"true","type":"blog","created_at":1431565269333,"created_by":1,"updated_at":1433865289330,"updated_by":1},{"id":13,"uuid":"c7aef7b4-0a06-4c1d-b27c-51d66a48e0b3","key":"permalinks","value":"/:slug/","type":"blog","created_at":1431565269333,"created_by":1,"updated_at":1433865289331,"updated_by":1},{"id":14,"uuid":"d199a183-92cf-48b9-a699-db642dda9b27","key":"ghost_head","value":"<script>\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\n\n  ga('create', 'UA-62982905-1', 'auto');\n  ga('send', 'pageview');\n\n</script>\n\n<!-- Go to www.addthis.com/dashboard to customize your tools -->\n<script type=\"text/javascript\" src=\"//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-55770ac61cd13df8\" async=\"async\"></script>\n","type":"blog","created_at":1431565269334,"created_by":1,"updated_at":1433865289335,"updated_by":1},{"id":15,"uuid":"2123da1a-9c73-45ad-8d3e-01964c53cb4d","key":"ghost_foot","value":"","type":"blog","created_at":1431565269335,"created_by":1,"updated_at":1433865289336,"updated_by":1},{"id":16,"uuid":"990dbef0-bed2-4eff-9957-0d66a274378d","key":"labs","value":"{}","type":"blog","created_at":1431565269335,"created_by":1,"updated_at":1433865289337,"updated_by":1},{"id":17,"uuid":"dc274bdf-075b-4a8f-9b5c-ccbfac446368","key":"navigation","value":"[{\"label\":\"Home\", \"url\":\"/\"}]","type":"blog","created_at":1431565269335,"created_by":1,"updated_at":1433865289339,"updated_by":1},{"id":18,"uuid":"8fae2482-685a-4a6d-a0f7-d3c31f8f8fd6","key":"activeApps","value":"[]","type":"app","created_at":1431565269335,"created_by":1,"updated_at":1431565269335,"updated_by":1},{"id":19,"uuid":"1eafc82b-0a04-4b4a-a3aa-f04d62c9bd2c","key":"installedApps","value":"[]","type":"app","created_at":"2015-05-14 01:01:09","created_by":1,"updated_at":"2016-08-04 18:11:56","updated_by":1},{"id":20,"uuid":"a51efd37-6a88-487e-83a4-94f3ee907a7a","key":"activeTheme","value":"casper","type":"theme","created_at":1431565269335,"created_by":1,"updated_at":1433865289334,"updated_by":1},{"id":21,"uuid":"601b4bf5-57db-4f43-9116-6ea69a04c760","key":"seenNotifications","value":"[]","type":"core","created_at":"2016-08-04 18:11:55","created_by":1,"updated_at":"2016-08-04 18:11:55","updated_by":1},{"id":22,"uuid":"cbb46f1c-4a8c-4471-8e82-1cea3da19d07","key":"migrations","value":"{}","type":"core","created_at":"2016-08-04 18:11:55","created_by":1,"updated_at":"2016-08-04 18:11:55","updated_by":1},{"id":23,"uuid":"6fe5b8d0-1165-4ad9-8384-2d1a17798a17","key":"activeTimezone","value":"Etc/UTC","type":"blog","created_at":"2016-08-04 18:11:55","created_by":1,"updated_at":"2016-08-04 18:11:55","updated_by":1},{"id":24,"uuid":"1fd2f49f-c287-43c7-966f-9d22e47232c7","key":"facebook","value":"","type":"blog","created_at":"2016-08-04 18:11:55","created_by":1,"updated_at":"2016-08-04 18:11:55","updated_by":1},{"id":25,"uuid":"7553253a-218d-4846-b82b-362b47d3fc7d","key":"twitter","value":"","type":"blog","created_at":"2016-08-04 18:11:55","created_by":1,"updated_at":"2016-08-04 18:11:55","updated_by":1},{"id":26,"uuid":"5a860d1d-160e-4741-b839-d5a82fd14613","key":"slack","value":"[{\"url\":\"\"}]","type":"blog","created_at":"2016-08-04 18:11:55","created_by":1,"updated_at":"2016-08-04 18:11:55","updated_by":1},{"id":27,"uuid":"310626c4-ad8d-488f-8e22-f5f8c6048e99","key":"isPrivate","value":"false","type":"private","created_at":"2016-08-04 18:11:55","created_by":1,"updated_at":"2016-08-04 18:11:55","updated_by":1},{"id":28,"uuid":"72f8f9ea-8a22-46ea-b567-e14cb8441802","key":"password","value":"","type":"private","created_at":"2016-08-04 18:11:55","created_by":1,"updated_at":"2016-08-04 18:11:55","updated_by":1}],"tags":[{"id":1,"uuid":"14b7066d-1ed9-4a09-9454-40c72e6bc941","name":"Getting Started","slug":"getting-started","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1431565266695,"created_by":1,"updated_at":1431565266695,"updated_by":1},{"id":2,"uuid":"94c68ff5-5e2a-4cfa-93b0-a3f33134a7cb","name":"family","slug":"family","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1431612049943,"created_by":1,"updated_at":1431612049943,"updated_by":1},{"id":3,"uuid":"28ec1cae-ea85-47d5-b112-f261a4514d76","name":"Algorithm  JAVA 3Sum","slug":"algorithm-java-3sum","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1431979193652,"created_by":1,"updated_at":1431979193652,"updated_by":1},{"id":4,"uuid":"87c67c49-6c8b-485c-895f-75169773410f","name":"Algorithm","slug":"algorithm","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1431979205930,"created_by":1,"updated_at":1431979205930,"updated_by":1},{"id":5,"uuid":"af8ee4d4-fb36-44ea-b00d-7f9ff4a18be9","name":"JAVA","slug":"java","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1431979212226,"created_by":1,"updated_at":1431979212226,"updated_by":1},{"id":6,"uuid":"a8b42337-43f4-41da-a345-20b565af03be","name":"3Sum","slug":"3sum","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1431979217823,"created_by":1,"updated_at":1431979217823,"updated_by":1},{"id":7,"uuid":"ecc4216b-48b6-49e2-9db2-57b838f90139","name":"fundation","slug":"fundation","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1432926181784,"created_by":1,"updated_at":1432926181784,"updated_by":1},{"id":8,"uuid":"97900ba3-2ead-4800-ae39-9e54cfcfe9e1","name":"JavaScript","slug":"javascript","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1438188621793,"created_by":1,"updated_at":1438188621793,"updated_by":1},{"id":9,"uuid":"bc7e5d6c-9709-4700-ad26-3ed61e189a5f","name":"Angular JS","slug":"angular-js","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1457840811027,"created_by":1,"updated_at":1457840811027,"updated_by":1},{"id":10,"uuid":"3fa9e36a-3668-4097-9f7d-8ddd0031bc37","name":"Node JS","slug":"node-js","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1458930192220,"created_by":1,"updated_at":1458930192220,"updated_by":1},{"id":11,"uuid":"92bbc8d8-a436-41ab-9313-f23a9ea169a3","name":"jwt","slug":"jwt","description":null,"image":null,"hidden":0,"parent_id":null,"meta_title":null,"meta_description":null,"created_at":1463773268591,"created_by":1,"updated_at":1463773268591,"updated_by":1}],"posts_tags":[{"id":55,"post_id":3,"tag_id":4},{"id":56,"post_id":3,"tag_id":5},{"id":57,"post_id":3,"tag_id":6},{"id":68,"post_id":6,"tag_id":5},{"id":69,"post_id":2,"tag_id":2},{"id":70,"post_id":5,"tag_id":5},{"id":71,"post_id":5,"tag_id":7},{"id":76,"post_id":10,"tag_id":8},{"id":78,"post_id":8,"tag_id":4},{"id":79,"post_id":12,"tag_id":8},{"id":80,"post_id":12,"tag_id":9},{"id":82,"post_id":13,"tag_id":10},{"id":95,"post_id":15,"tag_id":10},{"id":96,"post_id":15,"tag_id":11}],"apps":[],"app_settings":[],"app_fields":[]}}